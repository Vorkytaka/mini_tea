import 'package:mini_tea/feature.dart';
import 'package:test/test.dart';

// Test generated by chat gpt :)
void main() {
  group('_FeatureImpl', () {
    late Feature<int, String, String> feature;

    setUp(() {
      feature = Feature<int, String, String>(
        initialState: 0,
        update: (state, message) {
          if (message == 'same') {
            return (state, []);
          } else if (message == 'different') {
            return (state + 1, []);
          } else if (message == 'effects') {
            return (null, ['effect1', 'effect2']);
          } else if (message == 'state_and_effects') {
            return (state + 1, ['effect1']);
          }
          return (null, []);
        },
        effectHandlers: [],
      );
    });

    tearDown(() async {
      await feature.dispose();
    });

    test('does not emit a new state if the new state is null', () async {
      final states = <int>[];
      feature.stateStream.listen(states.add);

      feature.accept('noop');

      await Future.delayed(Duration.zero);
      expect(states, [0]);
    });

    test('does not emit a new state if the new state is the same', () async {
      final states = <int>[];
      feature.stateStream.listen(states.add);

      feature.accept('same');

      await Future.delayed(Duration.zero);
      expect(states, [0]);
    });

    test('emits a new state if the new state is different', () async {
      final states = <int>[];
      feature.stateStream.listen(states.add);

      feature.accept('different');

      await Future.delayed(Duration.zero);
      expect(states, [0, 1]);
    });

    test('emits effects returned by the update function', () async {
      final effects = <String>[];
      feature.effects.listen(effects.add);

      feature.accept('effects');

      await Future.delayed(Duration.zero);
      expect(effects, ['effect1', 'effect2']);
    });

    test('emits both state and effects if both are returned', () async {
      final states = <int>[];
      final effects = <String>[];

      feature.stateStream.listen(states.add);
      feature.effects.listen(effects.add);

      feature.accept('state_and_effects');

      await Future.delayed(Duration.zero);
      expect(states, [0, 1]);
      expect(effects, ['effect1']);
    });
  });
}
